// Code generated by glitch. DO NOT EDIT!
package errors

import "github.com/kalifun/glitch/repo/gerr"

var mqttTransportNotRunningErr = gerr.ErrWrapper{
	Key:      "MqttTransportNotRunning",
	Code:     "TransportNotRunning",
	Category: "system",
	Severity: gerr.SeverityError,
	Messages: map[string]string{
		"en": "MQTT transport is not running",
		"cn": "MQTT转换器没有启动",
	},
	Description: "mqtt transport not running",
}

var mqttTransportAlreadyRunningErr = gerr.ErrWrapper{
	Key:      "MqttTransportAlreadyRunning",
	Code:     "TransportAlreadyRunning",
	Category: "system",
	Severity: gerr.SeverityError,
	Messages: map[string]string{
		"cn": "MQTT转换器已经启动",
		"en": "MQTT transport already running",
	},
	Description: "mqtt transport already running",
}

var connectionFailedErr = gerr.ErrWrapper{
	Key:      "ConnectionFailed",
	Code:     "ConnectionFailed",
	Category: "network",
	Severity: gerr.SeverityError,
	Messages: map[string]string{
		"cn": "连接MQTT代理失败",
		"en": "Failed to connect to MQTT broker",
	},
	Description: "failed to connect to mqtt broker",
}

var authenticationFailedErr = gerr.ErrWrapper{
	Key:      "AuthenticationFailed",
	Code:     "AuthenticationFailed",
	Category: "security",
	Severity: gerr.SeverityError,
	Messages: map[string]string{
		"en": "MQTT authentication failed",
		"cn": "MQTT认证失败",
	},
	Description: "mqtt authentication failed",
}

var subscriptionFailedErr = gerr.ErrWrapper{
	Key:      "SubscriptionFailed",
	Code:     "SubscriptionFailed",
	Category: "network",
	Severity: gerr.SeverityError,
	Messages: map[string]string{
		"cn": "订阅主题失败",
		"en": "Failed to subscribe to topic",
	},
	Description: "failed to subscribe to topic",
}

var publishFailedErr = gerr.ErrWrapper{
	Key:      "PublishFailed",
	Code:     "PublishFailed",
	Category: "network",
	Severity: gerr.SeverityError,
	Messages: map[string]string{
		"cn": "发布消息失败",
		"en": "Failed to publish message",
	},
	Description: "failed to publish message",
}

var invalidTopicErr = gerr.ErrWrapper{
	Key:      "InvalidTopic",
	Code:     "InvalidTopic",
	Category: "validation",
	Severity: gerr.SeverityError,
	Messages: map[string]string{
		"en": "Invalid MQTT topic format",
		"cn": "无效的MQTT主题格式",
	},
	Description: "invalid mqtt topic format",
}

var clientNotConnectedErr = gerr.ErrWrapper{
	Key:      "ClientNotConnected",
	Code:     "ClientNotConnected",
	Category: "network",
	Severity: gerr.SeverityError,
	Messages: map[string]string{
		"en": "MQTT client is not connected",
		"cn": "MQTT客户端未连接",
	},
	Description: "mqtt client is not connected",
}

var reconnectFailedErr = gerr.ErrWrapper{
	Key:      "ReconnectFailed",
	Code:     "ReconnectFailed",
	Category: "network",
	Severity: gerr.SeverityError,
	Messages: map[string]string{
		"cn": "重新连接代理失败",
		"en": "Failed to reconnect to broker",
	},
	Description: "failed to reconnect to broker",
}

var tLSConfigErrorErr = gerr.ErrWrapper{
	Key:      "TLSConfigError",
	Code:     "TLSConfigError",
	Category: "security",
	Severity: gerr.SeverityError,
	Messages: map[string]string{
		"cn": "TLS配置无效",
		"en": "Invalid TLS configuration",
	},
	Description: "invalid tls configuration",
}

var willMessageErrorErr = gerr.ErrWrapper{
	Key:      "WillMessageError",
	Code:     "WillMessageError",
	Category: "validation",
	Severity: gerr.SeverityError,
	Messages: map[string]string{
		"cn": "遗嘱消息配置无效",
		"en": "Invalid will message configuration",
	},
	Description: "invalid will message configuration",
}

var qosNotSupportedErr = gerr.ErrWrapper{
	Key:      "QosNotSupported",
	Code:     "QosNotSupported",
	Category: "validation",
	Severity: gerr.SeverityError,
	Messages: map[string]string{
		"cn": "不支持的QoS级别",
		"en": "Requested QoS level not supported",
	},
	Description: "requested qos level not supported",
}

var messageTooLargeErr = gerr.ErrWrapper{
	Key:      "MessageTooLarge",
	Code:     "MessageTooLarge",
	Category: "validation",
	Severity: gerr.SeverityError,
	Messages: map[string]string{
		"cn": "消息大小超过限制",
		"en": "Message size exceeds limit",
	},
	Description: "message size exceeds limit",
}

var brokerUnavailableErr = gerr.ErrWrapper{
	Key:      "BrokerUnavailable",
	Code:     "BrokerUnavailable",
	Category: "network",
	Severity: gerr.SeverityError,
	Messages: map[string]string{
		"en": "MQTT broker is unavailable",
		"cn": "MQTT代理不可用",
	},
	Description: "mqtt broker is unavailable",
}

var protocolErrorErr = gerr.ErrWrapper{
	Key:      "ProtocolError",
	Code:     "ProtocolError",
	Category: "protocol",
	Severity: gerr.SeverityError,
	Messages: map[string]string{
		"cn": "MQTT协议错误",
		"en": "MQTT protocol error",
	},
	Description: "mqtt protocol error",
}

var timeoutErrorErr = gerr.ErrWrapper{
	Key:      "TimeoutError",
	Code:     "TimeoutError",
	Category: "network",
	Severity: gerr.SeverityError,
	Messages: map[string]string{
		"cn": "操作超时",
		"en": "Operation timed out",
	},
	Description: "operation timed out",
}

var alreadySubscribedErr = gerr.ErrWrapper{
	Key:      "AlreadySubscribed",
	Code:     "AlreadySubscribed",
	Category: "validation",
	Severity: gerr.SeverityWarning,
	Messages: map[string]string{
		"en": "Already subscribed to topic",
		"cn": "已经订阅该主题",
	},
	Description: "already subscribed to topic",
}

var notSubscribedErr = gerr.ErrWrapper{
	Key:      "NotSubscribed",
	Code:     "NotSubscribed",
	Category: "validation",
	Severity: gerr.SeverityWarning,
	Messages: map[string]string{
		"en": "Not subscribed to topic",
		"cn": "未订阅该主题",
	},
	Description: "not subscribed to topic",
}

var invalidPayloadErr = gerr.ErrWrapper{
	Key:      "InvalidPayload",
	Code:     "InvalidPayload",
	Category: "validation",
	Severity: gerr.SeverityError,
	Messages: map[string]string{
		"cn": "无效的消息负载",
		"en": "Invalid message payload",
	},
	Description: "invalid message payload",
}

var configurationErrorErr = gerr.ErrWrapper{
	Key:      "ConfigurationError",
	Code:     "ConfigurationError",
	Category: "validation",
	Severity: gerr.SeverityError,
	Messages: map[string]string{
		"cn": "MQTT配置无效: %s",
		"en": "Invalid MQTT configuration: %s",
	},
	Description: "invalid mqtt configuration",
}

var subscriptionNotActiveErr = gerr.ErrWrapper{
	Key:      "SubscriptionNotActive",
	Code:     "SubscriptionNotActive",
	Category: "network",
	Severity: gerr.SeverityError,
	Messages: map[string]string{
		"cn": "主题 %s 的订阅未激活",
		"en": "Subscription to topic %s is not active",
	},
	Description: "subscription to topic is not active",
}

var unsubscribeFailedErr = gerr.ErrWrapper{
	Key:      "UnsubscribeFailed",
	Code:     "UnsubscribeFailed",
	Category: "network",
	Severity: gerr.SeverityError,
	Messages: map[string]string{
		"cn": "取消订阅主题 %s 失败: %v",
		"en": "Failed to unsubscribe from topic %s: %v",
	},
	Description: "failed to unsubscribe from topic",
}

// MqttTransportNotRunning represents mqtt transport not running
var MqttTransportNotRunning = gerr.NewError(mqttTransportNotRunningErr)

// MqttTransportAlreadyRunning represents mqtt transport already running
var MqttTransportAlreadyRunning = gerr.NewError(mqttTransportAlreadyRunningErr)

// ConnectionFailed represents failed to connect to mqtt broker
var ConnectionFailed = gerr.NewError(connectionFailedErr)

// AuthenticationFailed represents mqtt authentication failed
var AuthenticationFailed = gerr.NewError(authenticationFailedErr)

// SubscriptionFailed represents failed to subscribe to topic
var SubscriptionFailed = gerr.NewError(subscriptionFailedErr)

// PublishFailed represents failed to publish message
var PublishFailed = gerr.NewError(publishFailedErr)

// InvalidTopic represents invalid mqtt topic format
var InvalidTopic = gerr.NewError(invalidTopicErr)

// ClientNotConnected represents mqtt client is not connected
var ClientNotConnected = gerr.NewError(clientNotConnectedErr)

// ReconnectFailed represents failed to reconnect to broker
var ReconnectFailed = gerr.NewError(reconnectFailedErr)

// TLSConfigError represents invalid tls configuration
var TLSConfigError = gerr.NewError(tLSConfigErrorErr)

// WillMessageError represents invalid will message configuration
var WillMessageError = gerr.NewError(willMessageErrorErr)

// QosNotSupported represents requested qos level not supported
var QosNotSupported = gerr.NewError(qosNotSupportedErr)

// MessageTooLarge represents message size exceeds limit
var MessageTooLarge = gerr.NewError(messageTooLargeErr)

// BrokerUnavailable represents mqtt broker is unavailable
var BrokerUnavailable = gerr.NewError(brokerUnavailableErr)

// ProtocolError represents mqtt protocol error
var ProtocolError = gerr.NewError(protocolErrorErr)

// TimeoutError represents operation timed out
var TimeoutError = gerr.NewError(timeoutErrorErr)

// AlreadySubscribed represents already subscribed to topic
var AlreadySubscribed = gerr.NewError(alreadySubscribedErr)

// NotSubscribed represents not subscribed to topic
var NotSubscribed = gerr.NewError(notSubscribedErr)

// InvalidPayload represents invalid message payload
var InvalidPayload = gerr.NewError(invalidPayloadErr)

// ConfigurationError represents invalid mqtt configuration
var ConfigurationError = gerr.NewError(configurationErrorErr)

// SubscriptionNotActive represents subscription to topic is not active
var SubscriptionNotActive = gerr.NewError(subscriptionNotActiveErr)

// UnsubscribeFailed represents failed to unsubscribe from topic
var UnsubscribeFailed = gerr.NewError(unsubscribeFailedErr)

func init() {
	if err := gerr.Register(mqttTransportNotRunningErr); err != nil {
		panic(err)
	}
	if err := gerr.Register(mqttTransportAlreadyRunningErr); err != nil {
		panic(err)
	}
	if err := gerr.Register(connectionFailedErr); err != nil {
		panic(err)
	}
	if err := gerr.Register(authenticationFailedErr); err != nil {
		panic(err)
	}
	if err := gerr.Register(subscriptionFailedErr); err != nil {
		panic(err)
	}
	if err := gerr.Register(publishFailedErr); err != nil {
		panic(err)
	}
	if err := gerr.Register(invalidTopicErr); err != nil {
		panic(err)
	}
	if err := gerr.Register(clientNotConnectedErr); err != nil {
		panic(err)
	}
	if err := gerr.Register(reconnectFailedErr); err != nil {
		panic(err)
	}
	if err := gerr.Register(tLSConfigErrorErr); err != nil {
		panic(err)
	}
	if err := gerr.Register(willMessageErrorErr); err != nil {
		panic(err)
	}
	if err := gerr.Register(qosNotSupportedErr); err != nil {
		panic(err)
	}
	if err := gerr.Register(messageTooLargeErr); err != nil {
		panic(err)
	}
	if err := gerr.Register(brokerUnavailableErr); err != nil {
		panic(err)
	}
	if err := gerr.Register(protocolErrorErr); err != nil {
		panic(err)
	}
	if err := gerr.Register(timeoutErrorErr); err != nil {
		panic(err)
	}
	if err := gerr.Register(alreadySubscribedErr); err != nil {
		panic(err)
	}
	if err := gerr.Register(notSubscribedErr); err != nil {
		panic(err)
	}
	if err := gerr.Register(invalidPayloadErr); err != nil {
		panic(err)
	}
	if err := gerr.Register(configurationErrorErr); err != nil {
		panic(err)
	}
	if err := gerr.Register(subscriptionNotActiveErr); err != nil {
		panic(err)
	}
	if err := gerr.Register(unsubscribeFailedErr); err != nil {
		panic(err)
	}
}

// NewMqttTransportNotRunningWithMetadata creates a MqttTransportNotRunning error with metadata
func NewMqttTransportNotRunningWithMetadata(key string, value interface{}) *gerr.Error {
	return MqttTransportNotRunning.With(key, value)
}

// NewMqttTransportAlreadyRunningWithMetadata creates a MqttTransportAlreadyRunning error with metadata
func NewMqttTransportAlreadyRunningWithMetadata(key string, value interface{}) *gerr.Error {
	return MqttTransportAlreadyRunning.With(key, value)
}

// NewConnectionFailedWithMetadata creates a ConnectionFailed error with metadata
func NewConnectionFailedWithMetadata(key string, value interface{}) *gerr.Error {
	return ConnectionFailed.With(key, value)
}

// NewAuthenticationFailedWithMetadata creates a AuthenticationFailed error with metadata
func NewAuthenticationFailedWithMetadata(key string, value interface{}) *gerr.Error {
	return AuthenticationFailed.With(key, value)
}

// NewSubscriptionFailedWithMetadata creates a SubscriptionFailed error with metadata
func NewSubscriptionFailedWithMetadata(key string, value interface{}) *gerr.Error {
	return SubscriptionFailed.With(key, value)
}

// NewPublishFailedWithMetadata creates a PublishFailed error with metadata
func NewPublishFailedWithMetadata(key string, value interface{}) *gerr.Error {
	return PublishFailed.With(key, value)
}

// NewInvalidTopicWithMetadata creates a InvalidTopic error with metadata
func NewInvalidTopicWithMetadata(key string, value interface{}) *gerr.Error {
	return InvalidTopic.With(key, value)
}

// NewClientNotConnectedWithMetadata creates a ClientNotConnected error with metadata
func NewClientNotConnectedWithMetadata(key string, value interface{}) *gerr.Error {
	return ClientNotConnected.With(key, value)
}

// NewReconnectFailedWithMetadata creates a ReconnectFailed error with metadata
func NewReconnectFailedWithMetadata(key string, value interface{}) *gerr.Error {
	return ReconnectFailed.With(key, value)
}

// NewTLSConfigErrorWithMetadata creates a TLSConfigError error with metadata
func NewTLSConfigErrorWithMetadata(key string, value interface{}) *gerr.Error {
	return TLSConfigError.With(key, value)
}

// NewWillMessageErrorWithMetadata creates a WillMessageError error with metadata
func NewWillMessageErrorWithMetadata(key string, value interface{}) *gerr.Error {
	return WillMessageError.With(key, value)
}

// NewQosNotSupportedWithMetadata creates a QosNotSupported error with metadata
func NewQosNotSupportedWithMetadata(key string, value interface{}) *gerr.Error {
	return QosNotSupported.With(key, value)
}

// NewMessageTooLargeWithMetadata creates a MessageTooLarge error with metadata
func NewMessageTooLargeWithMetadata(key string, value interface{}) *gerr.Error {
	return MessageTooLarge.With(key, value)
}

// NewBrokerUnavailableWithMetadata creates a BrokerUnavailable error with metadata
func NewBrokerUnavailableWithMetadata(key string, value interface{}) *gerr.Error {
	return BrokerUnavailable.With(key, value)
}

// NewProtocolErrorWithMetadata creates a ProtocolError error with metadata
func NewProtocolErrorWithMetadata(key string, value interface{}) *gerr.Error {
	return ProtocolError.With(key, value)
}

// NewTimeoutErrorWithMetadata creates a TimeoutError error with metadata
func NewTimeoutErrorWithMetadata(key string, value interface{}) *gerr.Error {
	return TimeoutError.With(key, value)
}

// NewAlreadySubscribedWithMetadata creates a AlreadySubscribed error with metadata
func NewAlreadySubscribedWithMetadata(key string, value interface{}) *gerr.Error {
	return AlreadySubscribed.With(key, value)
}

// NewNotSubscribedWithMetadata creates a NotSubscribed error with metadata
func NewNotSubscribedWithMetadata(key string, value interface{}) *gerr.Error {
	return NotSubscribed.With(key, value)
}

// NewInvalidPayloadWithMetadata creates a InvalidPayload error with metadata
func NewInvalidPayloadWithMetadata(key string, value interface{}) *gerr.Error {
	return InvalidPayload.With(key, value)
}

// ConfigurationErrorF indicates this error requires format arguments
// Usage: ConfigurationErrorF.Args("ErrMessage")
var ConfigurationErrorF = ConfigurationError

// NewConfigurationErrorWithArgs creates a ConfigurationError error with arguments
func NewConfigurationErrorWithArgs(args ...interface{}) *gerr.Error {
	return ConfigurationError.Args(args...)
}

// NewConfigurationErrorWithMetadata creates a ConfigurationError error with metadata
func NewConfigurationErrorWithMetadata(key string, value interface{}) *gerr.Error {
	return ConfigurationError.With(key, value)
}

// SubscriptionNotActiveF indicates this error requires format arguments
// Usage: SubscriptionNotActiveF.Args("ErrMessage")
var SubscriptionNotActiveF = SubscriptionNotActive

// NewSubscriptionNotActiveWithArgs creates a SubscriptionNotActive error with arguments
func NewSubscriptionNotActiveWithArgs(args ...interface{}) *gerr.Error {
	return SubscriptionNotActive.Args(args...)
}

// NewSubscriptionNotActiveWithMetadata creates a SubscriptionNotActive error with metadata
func NewSubscriptionNotActiveWithMetadata(key string, value interface{}) *gerr.Error {
	return SubscriptionNotActive.With(key, value)
}

// UnsubscribeFailedF indicates this error requires format arguments
// Usage: UnsubscribeFailedF.Args("ErrMessage")
var UnsubscribeFailedF = UnsubscribeFailed

// NewUnsubscribeFailedWithArgs creates a UnsubscribeFailed error with arguments
func NewUnsubscribeFailedWithArgs(args ...interface{}) *gerr.Error {
	return UnsubscribeFailed.Args(args...)
}

// NewUnsubscribeFailedWithMetadata creates a UnsubscribeFailed error with metadata
func NewUnsubscribeFailedWithMetadata(key string, value interface{}) *gerr.Error {
	return UnsubscribeFailed.With(key, value)
}
